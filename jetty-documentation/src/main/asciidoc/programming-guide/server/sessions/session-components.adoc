//
// ========================================================================
// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.
//
// This program and the accompanying materials are made available under
// the terms of the Eclipse Public License 2.0 which is available at
// https://www.eclipse.org/legal/epl-2.0
//
// This Source Code may also be made available under the following
// Secondary Licenses when the conditions for such availability set
// forth in the Eclipse Public License, v. 2.0 are satisfied:
// the Apache License v2.0 which is available at
// https://www.apache.org/licenses/LICENSE-2.0
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
// ========================================================================
//

[[pg-server-session-components]]
==== Session Components

===== SessionIdManager

There is a maximum of one `SessionIdManager` per `Server` instance.
Its purpose is to generate fresh, unique session ids and to coordinate the re-use of session ids amongst co-operating contexts.

The `SessionIdManager` is agnostic with respect to the type of clustering technology chosen.

Jetty provides a default implementation - the link:{JDURL}/org/eclipse/jetty/server/session/DefaultSessionIdManager.html[DefaultSessionIdManager]  - which should meet the needs of most users.
If you do not explicitly enable one of the session modules or otherwise configure a `SessionIdManager`, the `DefaultSessionIdManager` will be used.

If the `DefaultSessionIdManager` does not meet your needs, you can extend the link:{JDURL}/org/eclipse/jetty/server/session/AbstractSessionIdManager.html[AbstractSessionIdManager] or do a fresh implementation of the link:{JDURL}/org/eclipse/jetty/server/session/SessionIdManager.html[SessionIdManager] interface.

See xref:#pg-server-session-sessionidmgr[the SessionIdManager] for more information.

===== HouseKeeper

There is a maximum of one (1) link:{JDURL}/org/eclipse/jetty/server/session/HouseKeeper.html[HouseKeeper] per `SessionIdManager`.
Its purpose is to periodically poll the link:{JDURL}/org/eclipse/jetty/server/session/SessionHandler.html[SessionHandlers] to clean out expired sessions.

By default the `HouseKeeper` will poll the `SessionHandler``s every 10 mins to find and delete expired sessions, although this interval is configurable.

See xref:#pg-server-session-housekeeper[the HouseKeeper] for more information


===== SessionCache

There is one (1) `SessionCache` *per context.*
Its purpose is to provide an L1 cache of `Session` objects.
Having a working set of `Session` objects in memory allows multiple simultaneous requests for the same session to share the same `Session` object.

Jetty provides two (2) `SessionCache` implementations: the link:{JDURL}/org/eclipse/jetty/server/session/DefaultSessionCache.html[DefaultSessionCache] and the link:{JDURL}/org/eclipse/jetty/server/session/NullSessionCache.html[NullSessionCache].
The `DefaultSessionCache` retains `Session` objects in memory in a cache and has a number of xref:#pg-server-session-sessioncache[configuration options] to control cache behavior.
It is the default that is used if no other `SessionCache` has been configured.
It is suitable for non-clustered and clustered deployments with a sticky load balancer, as well as clustered deployments with a non-sticky load balancer, with some caveats.

The `NullSessionCache` does not actually cache any objects: each request uses a fresh `Session` object.
It is suitable for clustered deployments without a sticky load balancer and non-clustered deployments when purely minimal support for sessions is needed.

``SessionCache``s always write out a Session to the link:{JDURL}/org/eclipse/jetty/server/session/SessionDataStore.html[SessionDataStore] whenever the last request for the `Session` exits.

They can also be configured to do an immediate, eager write of a freshly created session.
This can be useful if you are likely to experience multiple, near simultaneous requests referencing the same session, e.g. with HTTP/2 and you don't have a sticky load balancer.
Alternatively, if the eager write is not done, application paths which create and then invalidate a session within a single request never incur the cost of writing to persistent storage.

Additionally, if the `EVICT_ON_INACTIVITY` eviction policy is in use, you can xref:#pg-server-session-sessioncache[configure] the `DefaultSessionCache` to force a write of the `Session` to the `SessionDataStore` just before the `Session` is evicted.

See xref:#pg-server-session-sessioncache[the L1 Session Cache] for more information.

===== SessionDataStore

There is one (1) link:{JDURL}/org/eclipse/jetty/server/session/SessionDataStore.html[SessionDataStore] per context.
Its purpose is to handle all persistence/clustering related operations on sessions.

The common characteristics for all ``SessionDataStore``s are whether or not they support passivation, and the length of the grace period.

Supporting passivation means that session data is serialized.
Some persistence mechanisms serialize, such as JDBC, GCloud Datastore etc, whereas others may store an object in shared memory, e.g. Infinispan, when configured with a local cache.

Whether or not a clustering technology entails passivation controls whether or not the session passivation/activation listeners will be called.

The grace period is an interval, configured in seconds, that attempts to deal with the non-transactional nature of sessions with regard to finding sessions that have expired.
Due to the lack of transactionality, in a clustered configuration, even with a sticky load balancer, it is always possible that a session is live on a node but has not yet been updated in the persistent store.
When ``SessionDataStore``s search their persistent store to find sessions that have expired, they typically perform a few sequential searches:

* The first verifies the expiration of a list of candidate session ids suggested by the `SessionCache`
* The second finds sessions in the store that have expired which were last live on the current node
* The third finds sessions that expired a "while" ago, irrespective of on which node they were last used: the definition of "a while" is based on the grace period.

The trivial link:{JDURL}/org/eclipse/jetty/server/session/NullSessionDataStore.html[NullSessionDataStore] - which does not persist sessions - is the default used by the `SessionHandler`.

The server libraries provide a number of alternative `SessionDataStore` implementations such as xref:#pg-server-session-filesystem[FileSessionDataStore], xref:#pg-server-session-gcloud[GCloudSessionDataStore], xref:#pg-server-session-jdbc[JDBCSessionDataStore], xref:#pg-server-session-mongodb[MongoSessionDataStore], xref:#pg-server-session-infinispan[InfinispanSessionDataStore], xref:#pg-server-session-hazelcast[HazelcastSessionDataStore].


===== CachingSessionDataStore

The `CachingSessionDataStore` is a special type of `SessionDataStore` that inserts an L2 cache of `Session` data - the link:{JDURL}/org/eclipse/jetty/server/session/SessionDataMap.html[SessionDataMap] - in front of a delegate `SessionDataStore`.
The `SessionDataMap` is preferentially consulted before the actual `SessionDataStore` on reads.
This can improve the performance of slow stores.

Jetty provides one implementation of the this L2 cache based on `Memcached`, the `MemcachedSessionDataMap`.

See xref:#pg-serversession-memcachedsessiondatastore[the L2 SessionData Cache]for additional information.
